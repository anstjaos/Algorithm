```java
class Solution {
    private int[] parent;
    private int[] rank;

    public List<List<String>> accountsMerge(List<List<String>> accounts) {
        int size = accounts.size();
        this.parent = new int[size];
        this.rank = new int[size];

        for (int i = 0; i < size; i++) {
            parent[i] = i;
        }

        Map<String, Integer> emailIndexMap = new HashMap<>();
        List<List<String>> temp = new ArrayList<>();

        for (int i = 0; i < size; i++) {
            List<String> emails = accounts.get(i);
            for (int j = 1 ; j < emails.size(); j++) {
                String email = emails.get(j);
                if (emailIndexMap.containsKey(email)) {
                    union(i, emailIndexMap.get(email));
                } else {
                    emailIndexMap.put(email, i);
                }
            }
            
            temp.add(new ArrayList<>());
        }

        for (String email : emailIndexMap.keySet()) {
            int root = findParent(emailIndexMap.get(email));
            temp.get(root).add(email);
        }

        List<List<String>> result = new ArrayList<>();
        for (int i = 0; i < size; i++) {
            if (!temp.get(i).isEmpty()) {
                Collections.sort(temp.get(i));
                temp.get(i).add(0, accounts.get(i).get(0));
                result.add(temp.get(i));
            }
        }

        return result;
    }

    private int findParent(int index) {
        if (parent[index] != index) {
            parent[index] = findParent(parent[index]);
        }

        return parent[index];
    }

    private void union(int p, int q) {
        int pParent = findParent(p);
        int qParent = findParent(q);

        if (rank[pParent] > rank[qParent]) {
            parent[qParent] = parent[pParent];
            rank[pParent]++;
        } else {
            parent[pParent] = parent[qParent];
            rank[qParent]++;
        }
    }
}
```